##第六章 JpaRepository扩展之QueryByExampleExecutor
>从本章开始，我们进入到JPA的核心部分，我们先来讲一下QueryByExampleExecutor的使用

###6.1 JpaRepository介绍
从JpaRepository开始的子类，都是Spring Data项目对JPA实现的封装与扩展。JpaRepository本身继承PagingAndSortingRepository接口，是针对JPA技术的接口，提供flush()，saveAndFlush()，deleteInBatch()，deleteAllInBatch()等方法。我们来看一下UML来对JpaRespository有个整体的认识。

![enter image description here](http://images.gitbook.cn/af50bef0-2eab-11e8-8e27-3f3d79ceb212)  

1. 从图中其实我们可以发现，JPA的实现类，最关键是：`SimpleJpaRepository`，我们多次提到。还有一个最关键的实现类是QuerydslJpaRepository，我们会在后面继续介绍。
2. 从图中我们还可以看出来，最关键的几个接口QueryByExampleExecutor，JpaSpecificationExecutor。
3. 从图中我们我们还可以好好体会一些接口的用意（暴露哪些该暴露的操作方法，而不是一股脑的把所有的方法都暴露给使用的人，因为不是每个场景下面我们都会用到所有方法。`作者感悟：实际工作当我们去设计我们的公共方法或者架构的时候，要充分考虑清楚抽象类和接口的区别及其应用场景。`）

### 6.2 QueryByExampleExecutor的使用
按示例查询（QBE）是一种用户友好的查询技术，具有简单的接口.它允许动态查询创建，并且不需要编写包含字段名称的查询。从UML图中，可以看出继承JpaRepository接口后，自动拥有了按“实例”进行查询的诸多方法。可见Spring Data的团队已经认为了QBE是Spring Jpa的基本功能了，继承QueryByExampleExecutor和继承JpaRepository都会有这些基本方法，所以QueryByExampleExecutor位于Spring Data common中，而JpaRepository位于Spring Data Jpa中。
### 6.3 QueryByExampleExecutor详细配置
先来看一下QueryByExampleExecutor的源码

````
public interface QueryByExampleExecutor<T> { 
 //根据“实例”查找一个对象。
<S extends T> S findOne(Example<S> example);
//根据“实例”查找一批对象
<S extends T> Iterable<S> findAll(Example<S> example); 
//根据“实例”查找一批对象，且排序
<S extends T> Iterable<S> findAll(Example<S> example, Sort sort);
 //根据“实例”查找一批对象，且排序和分页 
<S extends T> Page<S> findAll(Example<S> example, Pageable pageable);
//根据“实例”查找，返回符合条件的对象个数
<S extends T> long count(Example<S> example); 
//根据“实例”判断是否有符合条件的对象
<S extends T> boolean exists(Example<S> example); 
}
````
从源码上我们可以看出，只要了解Example基本上就可以掌握的它的用法和API了。

````
public class Example<T> {
    @NonNull
    private final T probe;
    @NonNull
    private final ExampleMatcher matcher;
public static <T> Example<T> of(T probe) {
    return new Example(probe, ExampleMatcher.matching());
}
public static <T> Example<T> of(T probe, ExampleMatcher matcher) {
    return new Example(probe, matcher);
}
......
}
````
我们从源码中可以看出Example主要包含三部分内容：
  
  1. Probe：这是具有填充字段的域对象的实际实体类，既查询条件的封装类（又可以理解为：查询条件参数）。必填。
  1. ExampleMatcher：ExampleMatcher有关于如何匹配特定字段的匹配规则，它可以重复使用在多个示例。必填。如果不填，用默认的。（又可以理解为参数的匹配规则）。
  1. Example：Example由Probe探针和ExampleMatcher组成。它用于创建查询，既（查询参数，参数匹配规则）。

### 6.4 QueryByExampleExecutor的使用案例

````
//创建查询条件数据对象
Customer customer = new Customer();
customer.setName("Jack");
customer.setAddress("上海");
//创建匹配器，即如何使用查询条件
ExampleMatcher matcher = ExampleMatcher.matching() //构建对象
        .withMatcher("name", GenericPropertyMatchers.startsWith()) //姓名采用“开始匹配”的方式查询
        .withIgnorePaths("focus");  //忽略属性：是否关注。因为是基本类型，需要忽略掉
//创建实例
Example<Customer> ex = Example.of(customer, matcher); 
//查询
List<Customer> ls = dao.findAll(ex);
//输出结果
for (Customer bo:ls)
{
    System.out.println(bo.getName());
}
````
上面例子中，是这样创建“实例”的：`Example<Customer> ex = Example.of(customer, matcher);`我们看到，Example对象，由customer和matcher共同创建，为讲解方便，我们再来结合案例先来明确一些定义。

   - A、Probe：实体对象，在持久化框架中与Table对应的域对象，一个对象代表数据库表中的一条记录，如上例中Customer对象。在构建查询条件时，一个实体对象代表的是查询条件中的“数值”部分。如：要查询姓“Jack”的客户，实体对象只能存储条件值“Jack”。
   -     B、ExampleMatcher：匹配器，它是匹配“实体对象”的，表示了如何使用“实体对象”中的“值”进行查询，它代表的是“查询方式”，解释了如何去查的问题。如：要查询姓“刘”的客户，即姓名以“刘”开头的客户，该对象就表示了“以某某开头的”这个查询方式，如上例中:withMatcher("name", GenericPropertyMatchers.startsWith())
   -     C、Example：实例对象，代表的是完整的查询条件。由实体对象（查询条件值）和匹配器（查询方式）共同创建。
    再来理解“实例查询”，顾名思义，就是通过一个例子来查询。要查询的是Customer对象，查询条件也是一个Customer对象，通过一个现有的客户对象作为例子，查询和这个例子相匹配的对象。
    
### 6.5 QueryByExampleExecutor的特点及约束

1. 支持动态查询。即支持查询条件个数不固定的情况，如：客户列表中有多个过滤条件，用户使用时在“地址”查询框中输入了值，就需要按地址进行过滤，如果没有输入值，就忽略这个过滤条件。对应的实现是，在构建查询条件Customer对象时，将address属性值置具体的条件值或置为null。
1. 不支持过滤条件分组。即不支持过滤条件用 or(或) 来连接，所有的过滤查件，都是简单一层的用 and(并且) 连接。`如 firstname = ?0 or (firstname = ?1 and lastname = ?2)。`
1. 仅支持字符串的开始/包含/结束/正则表达式匹配和其他属性类型的精确匹配。查询时，对一个要进行匹配的属性（如：姓名 name），只能传入一个过滤条件值，如以Customer为例，要查询姓“刘”的客户，“刘”这个条件值就存储在表示条件对象的Customer对象的name属性中，针对于“姓名”的过滤也只有这么一个存储过滤值的位置，没办法同时传入两个过滤值。正是由于这个限制，有些查询是没办法支持的，例如要查询某个时间段内添加的客户，对应的属性是 addTime，需要传入“开始时间”和“结束时间”两个条件值，而这种查询方式没有存两个值的位置，所以就没办法完成这样的查询。

### 6.6 ExampleMatcher源码解读：
1）源码解读

````
public class ExampleMatcher {
NullHandler nullHandler; 
StringMatcher defaultStringMatcher; //默认
boolean defaultIgnoreCase; //默认大小写忽略方式
PropertySpecifiers propertySpecifiers; //各属性特定查询方式
Set<String> ignoredPaths; //忽略属性列表
//Null值处理方式，通过构造方法，我们发现默认忽略
   NullHandler nullHandler;
   //字符串匹配方式,通过构造方法可以看出默认是DEFAULT（默认，效果同EXACT）,EXACT（相等）
   StringMatcher defaultStringMatcher;
   //各属性特定查询方式，默认无特殊指定的。
   PropertySpecifiers propertySpecifiers;
   //忽略属性列表，默认无。
   Set<String> ignoredPaths;
   //大小写忽略方式,默认不忽略。
   boolean defaultIgnoreCase;
   @Wither(AccessLevel.PRIVATE) MatchMode mode;
//通用、内部、默认构造方法。
   private ExampleMatcher() {
      this(NullHandler.IGNORE, StringMatcher.DEFAULT, new PropertySpecifiers(), Collections.<String>emptySet(), false,
            MatchMode.ALL);
   }
   //Example的默认匹配方式
   public static ExampleMatcher matching() {
      return matchingAll();
   }
public static ExampleMatcher matchingAll() {
   return new ExampleMatcher().withMode(MatchMode.ALL);
}
......
}
````
2）关键属性分析

````
（1）nullHandler：Null值处理方式，枚举类型，有2个可选值，INCLUDE（包括）,IGNORE（忽略）。
	标识作为条件的实体对象中，一个属性值（条件值）为Null是，是否参与过滤。
	当该选项值是INCLUDE时，表示仍参与过滤，会匹配数据库表中该字段值是Null的记录；
	若为IGNORE值，表示不参与过滤。
（2）defaultStringMatcher：默认字符串匹配方式，枚举类型，有6个可选值，DEFAULT（默认，效果同EXACT）,EXACT（相等）,STARTING（开始匹配）,ENDING（结束匹配）,CONTAINING（包含，模糊匹配）,REGEX（正则表达式）。
	该配置对所有字符串属性过滤有效，除非该属性在 propertySpecifiers 中单独定义自己的匹配方式。
（3）defaultIgnoreCase：默认大小写忽略方式，布尔型，当值为false时，即不忽略，大小不相等。
	该配置对所有字符串属性过滤有效，除非该属性在 propertySpecifiers 中单独定义自己的忽略大小写方式。
（4）propertySpecifiers：各属性特定查询方式，描述了各个属性单独定义的查询方式，每个查询方式中包含4个元素：属性名、字符串匹配方式、大小写忽略方式、属性转换器。
	如果属性未单独定义查询方式，或单独查询方式中，某个元素未定义（如：字符串匹配方式），则采用 ExampleMatcher 中定义的默认值，即上面介绍的 defaultStringMatcher 和 defaultIgnoreCase的值。
（5）ignoredPaths：忽略属性列表，忽略的属性不参与查询过滤。
````
3）字符串匹配举例

字符串匹配方式 | 对应JPQL的写法
--- | ---
Default&不忽略大小写  | firstname=?1
Exact&忽略大小写 |  LOWER(firstname) = LOWER(?1)
Staring&忽略大小写 |  LOWER(firstname) like LOWER(?0)+'%'
Ending&不忽略大小写  | firstname like '%'+?1
Containing不忽略大小写  | firstname like '%'+?1+'%'
### 6.7  QueryByExampleExecutor使用场景&实际的使用
#####6.7.1 使用场景：
使用一组静态或动态约束来查询数据存储、频繁重构域对象，而不用担心破坏现有查询、简单的查询的使用场景，有时候还是挺方便的。
#####6.7.2 实际使用中我们需要考虑的因素
查询条件的表示，有两部分，一是条件值，二是查询方式。条件值用实体对象（如Customer对象）来存储，相对简单，当页面传入过滤条件值时，存入相对应的属性中，没入传入时，属性保持默认值。查询方式是用匹配器ExampleMatcher来表示，情况相对复杂些，需要考虑的因素有：

- （1）Null值的处理。    
当某个条件值为Null,是应当忽略这个过滤条件呢，还是应当去匹配数据库表中该字段值是Null的记录？
Null值处理方式：默认值是 IGNORE（忽略），即当条件值为null时，则忽略此过滤条件，一般业务也是采用这种方式就可满足。当需要查询数据库表中属性为null的记录时，可将值设为INCLUDE，这时，对于不需要参与查询的属性，都必须添加到忽略列表（ignoredPaths）中，否则会出现查不到数据的情况。
- （2）基本类型的处理。    
如客户Customer对象中的年龄age是int型的，当页面不传入条件值时，它默认是0，是有值的，那是否参与查询呢？
关于基本数据类型处理方式：实体对象中，避免使用基本数据类型，采用包装器类型。如果已经采用了基本类型，而这个属性查询时不需要进行过滤，则把它添加到忽略列表（ignoredPaths）中。
- （3）忽略某些属性值。   
一个实体对象，有许多个属性，是否每个属性都参与过滤？是否可以忽略某些属性？
ignoredPaths：虽然某些字段里面有值或者设置了其它匹配规则，只要放在ignoredPaths中，就会忽略此字段的，不作为过滤条件。
- （4）不同的过滤方式。   
同样是作为String值，可能“姓名”希望精确匹配，“地址”希望模糊匹配，如何做到？
默认配置和特殊配置混合使用：默认创建匹配器时，字符串采用的是精确匹配、不忽略大小写，可以通过操作方法改变这种默认匹配，以满足大多数查询条件的需要，如将“字符串匹配方式”改为CONTAINING（包含，模糊匹配），这是比较常用的情况。对于个别属性需要特定的查询方式，可以通过配置“属性特定查询方式”来满足要求，设置propertySpecifiers的值即可。
- （5）大小写匹配。   
字符串匹配时，有时可能希望忽略大小写，有时则不忽略，如何做到？
defaultIgnoreCase：忽略大小的生效与否，是依赖于数据库的。例如 MySql 数据库中，默认创建表结构时，字段是已经忽略大小写的，所以这个配置与否，都是忽略的。如果业务需要严格区分大小写，可以改变数据库表结构属性来实现。

##### 6.7.3 实际使用案例说明：
1、无匹配器的情况    
要求：查询地址是“河南省郑州市”，且重点关注的客户。   
说明：使用默认匹配器就可以满足查询条件，则不需要创建匹配器。   

````
//创建查询条件数据对象
Customer customer = new Customer();
customer.setAddress("河南省郑州市");
customer.setFocus(true);
//创建实例
Example<Customer> ex = Example.of(customer); 
//查询
List<Customer> ls = dao.findAll(ex);
````
2、多种条件组合    
要求：根据姓名、地址、备注进行模糊查询，忽略大小写，地址要求开始匹配。     
说明：这是通用情况，主要演示改变默认字符串匹配方式、改变默认大小写忽略方式、属性特定查询方式配置、忽略属性列表配置。   

````
 //创建查询条件数据对象
Customer customer = new Customer();
customer.setName("zhang");
customer.setAddress("河南省");
customer.setRemark("BB");
//虽然有值，但是不参与过滤条件
customer.setFocus(true);
//创建匹配器，即如何使用查询条件
ExampleMatcher matcher = ExampleMatcher.matching() //构建对象
        .withStringMatcher(StringMatcher.CONTAINING) //改变默认字符串匹配方式：模糊查询
        .withIgnoreCase(true) //改变默认大小写忽略方式：忽略大小写
        .withMatcher("address", GenericPropertyMatchers.startsWith()) //地址采用“开始匹配”的方式查询
        .withIgnorePaths("focus");  //忽略属性：是否关注。因为是基本类型，需要忽略掉
//创建实例
Example<Customer> ex = Example.of(customer, matcher); 
//查询
List<Customer> ls = dao.findAll(ex);
````
3、多级查询   
要求：查询所有潜在客户   
说明：主要演示多层级属性查询   

````
//创建查询条件数据对象
CustomerType type = new CustomerType();
type.setCode("01"); //编号01代表潜在客户
Customer customer = new Customer();
customer.setCustomerType(type);        
//创建匹配器，即如何使用查询条件
ExampleMatcher matcher = ExampleMatcher.matching() //构建对象
        .withIgnorePaths("focus");  //忽略属性：是否关注。因为是基本类型，需要忽略掉                
//创建实例
Example<Customer> ex = Example.of(customer, matcher); 
//查询
List<Customer> ls = dao.findAll(ex);
````
4、查询Null值    
要求：地址是null的客户   
说明：主要演示改变“Null值处理方式”    

````
//创建查询条件数据对象
Customer customer = new Customer();
//创建匹配器，即如何使用查询条件
ExampleMatcher matcher = ExampleMatcher.matching() //构建对象
		//改变“Null值处理方式”：包括。
      .withIncludeNullValues() 
       //忽略其他属性
      .withIgnorePaths("id", "name", "sex", "age", "focus", "addTime", "remark", "customerType"); 
//创建实例
Example<Customer> ex = Example.of(customer, matcher);
//查询
List<Customer> ls = dao.findAll(ex);     
````
5、虽然我们工作中用的最多的还是“简单查询”（因为简单，所以...）和 基于JPA Criteria 的动态查询（可以满足所有需求，没有局限性）。    
但是QueryByExampleExecutor还是个非常不错的两种中间场景的查询处理手段，别人没有用，感觉是对其不熟悉，还是希望我们学习过QueryByExampleExecutor的开发者用起来的，用熟悉了会增加我们的开发效率。   
###6.8 QueryByExampleExecutor的实现源码
#####1）我们通过开发工具，Hierarchy，来看一下其接口的实现类有哪些：
![enter image description here](http://images.gitbook.cn/777c1cb0-2f03-11e8-8dc4-1735333b0b3b)
#####2）我们发现JpaSpecificationExecutor的实现类是SimpleJpaRepository。
而SimpleJpaRepository也实现了JpaSpecificationExecutor，于是就利用，Specification的特性，创建了内部类ExampleSpecification，通过Exmaple实现了一套工具类和对Predicate的构建，进而实现了整个ExampleQuery的逻辑。
>如果我们自己去看源码，会发现QueryByExampleExecutor给我们提供了两种思路：   
1）通过JpaSpecificationExecutor自定义Response的思路。   
2）和对JpaSpecificationExecutor的扩展思路。（后面章节自定义Repository中我们详细介绍）。   

####3）SimpleJpaRepository实现类中的关键源码：

````
public class SimpleJpaRepository<T, ID extends Serializable>
      implements JpaRepository<T, ID>, JpaSpecificationExecutor<T> {
   	private final EntityManager em;
public <S extends T> S findOne(Example<S> example) {
   try {
      return getQuery(new ExampleSpecification<S>(example), example.getProbeType(), (Sort) null).getSingleResult();
   } catch (NoResultException e) {
      return null;
   }
}
protected <S extends T> TypedQuery<S> getQuery(Specification<S> spec, Class<S> domainClass, Sort sort) {
   CriteriaBuilder builder = em.getCriteriaBuilder();
   CriteriaQuery<S> query = builder.createQuery(domainClass);
   Root<S> root = applySpecificationToCriteria(spec, domainClass, query);
   query.select(root);
   if (sort != null) {
      query.orderBy(toOrders(sort, root, builder));
   }
   return applyRepositoryMethodMetadata(em.createQuery(query));
}
......
}
````
####4）读SimpleJpaRepository源码给我大家的启示
当我们学习一个API的时候最好顺带读一下源码，分析一下它的实现结构，这样你会有意外发现：  

1. 学习源码的编程思想。
2. 学习源码的实现方式，我自己去写的时候如何写。这样可以很快的提高我们自己的编程水平。

