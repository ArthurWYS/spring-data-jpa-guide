##第二章 Jpa基础查询方法JpaRepository详解
> 本章节我们一起学习Spring Data Common里面的公用基本方法，本章不仅介绍用法，还会告诉大家一个更好的学习过程。    

### 2.1 Spring Data Common的Repository
Repository位于Spring Data Common的lib里面，是Spring Data 里面做数据库操作的最底层的抽象接口，最顶级的父类，我看源码其实里面什么方法都没有，仅仅起到一个标识左右。管理域类以及域类的id类型作为类型参数.此接口主要作为标记接口捕获要使用的类型，并帮助您发现扩展此接口的接口。Spring底层做动态代理的时候发现只要是它的子类或者实现类，都代表储存库操作。      
Repository的源码如下：

````
package org.springframework.data.repository;
import org.springframework.stereotype.Indexed;
@Indexed
public interface Repository<T, ID> {

}
````
有了这个类，我们就能顺腾摸瓜，找到好多spring data jpa自己的提供的基本接口和操作类，及其实现方法。这个接口定义了，所有Repostory操作的实体和ID的泛型参数。当不是继承任何就可，只要继承这个借口，就可以使用Spring jpa里面的提供的很多约定的方法查询和注解查询，后面章节会详细介绍。
### 2.2 Repository的类层次关系(diagms/hierarchy/structure)
我们来根据Repository这个基类，顺腾摸瓜看看Spring Data Jpa里面都有些什么？顺便教大家学习的方法，这样不管碰到学习任何一个框架，方法都雷同，自己逐步从入门到精通，提高学习效率。

#####1）我们用工具intellij idea，打开类Repository.class，然后点击Navigate -> Type Hierchy。
然后我们会得到如下视图：
![enter image description here](http://images.gitbook.cn/f61dc670-2aaf-11e8-9017-67397396aa0f)
通过这个层次结构视图，我们就会明白基类Repository的用意，我们让对工程里面的所有Repository了如执掌。我们项目里面有哪些，spring的项目里面有哪些一目了然。我们通过上面的类的结构图，我们可以看得出来Repository可以分为三个部分：

1. 就是本章节我们要讲的正常的JpaRepository这条线的操作。
2. Reactive**Repository这条线响应式编程，主要支持目前的Nosql方面的操作，因为大部分Nosql大部分的操作都是分布式的，所以足可以看的出来Spring Data 的野心，想提供关于所有data方面的操作。目前主要主要有Cassandra、MongoDB的实现，与JPA属于平级项目。
3. RxJava2CrudRepository这条线是为了支持RxJava2做的标准的响应式编程的接口。

#####2）我们也通过intellij idea,打开类上面我们的Example1里面的UserRepository.java点击鼠标右键show diagrams用图表的方式查看类的关系层次。打开如下图所示：  
![enter image description here](http://images.gitbook.cn/c9c95e50-2ab3-11e8-b513-03942d4be539)

#####3）我们也通过intellij idea,打开类QueryDslJpaRepository点击鼠标右键show diagrams用图表的方式查看类的关系层次。打开如下图所示：
![enter image description here](http://images.gitbook.cn/d2d8b450-2ab3-11e8-b513-03942d4be539)
#####4）我们也通过intellij idea,打开类上面我们的Example1里面的UserRepository.java打开Navigate -> File Structure。可以查看此类的结构，及有哪些方法，以此类推到其它类上。打开如下图所示：
![enter image description here](http://images.gitbook.cn/e14072d0-2ab3-11e8-acca-d972d7a925f0)
> 以上三种视图是开发过程中我们会经常用到的视图。而我们同过上面的图就可以知道如果我们要学习jpa或者是solr等其它Spring Data的实现的时候需要掌握哪些东西。我们本课程以JPA为主线来讲解。

我们来看一个Repository的实例：

````
package com.example.example2.repository;
import com.example.example2.entity.User;
import org.springframework.data.repository.Repository;
import java.util.List;
public interface UserRepository extends Repository<User,Integer> {
	/**
	 * 根据名称进行查询用户列表
	 * @param name
	 * @return
	 */
	List<User> findByName(String name);
	/**
	 * 根据用户的邮箱和名称查询
	 *
	 * @param email
	 * @param name
	 * @return
	 */
	List<User> findByEmailAndName(String email, String name);
}
````
### 2.3 CrudRepository方法详解
   通过上面类关系图可以看到CrudRepository提供了公共的通用的CRUD方法。
####2.3.1 CrudRepository interface内容

````
package org.springframework.data.repository;
import java.util.Optional;
@NoRepositoryBean
public interface CrudRepository<T, ID> extends Repository<T, ID> {
	<S extends T> S save(S entity);(1)
	<S extends T> Iterable<S> saveAll(Iterable<S> entities);(2)
	Optional<T> findById(ID id);(3)
	boolean existsById(ID id);(4)
	Iterable<T> findAll();(5)
	Iterable<T> findAllById(Iterable<ID> ids);(6)
	long count();(7)
	void deleteById(ID id);(8)
	void delete(T entity);(9)
	void deleteAll(Iterable<? extends T> entities);(10)
	void deleteAll();(11)
}
````

-（1）保存实体方法。
原理：我们通过刚才的类关系查看其实现类,SimpleJpaRepository里面的实现方法如下：

````
	@Transactional
	public <S extends T> S save(S entity) {
		if (entityInformation.isNew(entity)) {
			em.persist(entity);
			return entity;
		} else {
			return em.merge(entity);
		}
	}
````
我们发现他是先出查一下传进去的实体是不是存在，然后判断是新增还是更新。是不是存在根据两种机制，一种是根据主键来判断。还有一种是根据Version来判断，后面讲解Version的时候详解。所以我们如果去看jpa的控制台打印出来的SQL最少会有两条，一条是查询，一条是insert或者update。    
- （2）批量保存。原理和（1）相同。我们去看实现的话，就是for循环调用上面的save方法。  
- （3）根据主键查询实体。返回Jdk1.8的Optional，这可以可以避免null exception。    
- （4）根据主键判断实体是否存在。    
- （5）查询实体的所有列表。    
- （6）根据主键列表查询实体列表。    
- （7）查询总数。    
- （8）根据主键删除。查看源码我们发现，其是先查询出来再进行删除。   
- （9）根据entity进行删除。   
- （10）批量删除。   
- （11）删除所有。原理：我们通过刚才的类关系查看其的实现类，SimpleJpaRepository里面的delete实现方法如下,都是调用delete进行删除。 
   
````
	@Transactional
	public void deleteById(ID id) {
		Assert.notNull(id, ID_MUST_NOT_BE_NULL);
		delete(findById(id).orElseThrow(() -> new EmptyResultDataAccessException(
				String.format("No %s entity with id %s exists!", entityInformation.getJavaType(), id), 1)));
	}
	@Transactional
	public void delete(T entity) {
		Assert.notNull(entity, "The entity must not be null!");
		em.remove(em.contains(entity) ? entity : em.merge(entity));
	}
	@Transactional
	public void deleteAll(Iterable<? extends T> entities) {
		Assert.notNull(entities, "The given Iterable of entities not be null!");
		for (T entity : entities) {
			delete(entity);
		}
	}
````
> 我们发现关于update、delete、save等操作jpa自己也会去先查询一下，再去做保存。不存在抛出异常。特别强调了一下delete和save方法，是因为看到实际工作中，有同事会画蛇添足，自己在做save的时候先去find一下，其实是没有必要的，spring jpa底层都考虑到了。所以这里其实是想告诉大家，当我们用任何第三方方法的时候最好先查一下其源码和逻辑或者api再写出优雅的代码。

#### 2.3.2 CrudRepository interface的使用案例
使用也很多件单，只需要自己的Repository继承CrudRepository即可。
第一章的案例我们修改如下：UserCrudRepository继承CrudRepository

````
package com.example.example2.repository;
import com.example.example2.entity.User;
import org.springframework.data.repository.CrudRepository;
import java.util.List;
public interface UserCrudRepository extends CrudRepository<User,Integer> {
}
````
第一章的案例UserController我们的修改如下：

````
package com.example.example2;
import com.example.example2.entity.User;
import com.example.example2.repository.UserRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.ResponseBody;
import java.util.Optional;
@Controller
@RequestMapping(path = "/demo")
public class UserController {
	@Autowired
	private UserCrudRepository userRepository;

	@GetMapping(path = "/add")
	public void addNewUser(@RequestParam String name, @RequestParam String email) {
		User n = new User();
		n.setName(name);
		n.setEmail(email);
		userRepository.save(n);
	}

	@GetMapping(path = "/all")
	@ResponseBody

	public Iterable<User> getAllUsers() {
		return userRepository.findAll();
	}

	@GetMapping(path = "/info")
	@ResponseBody

	public Optional<User> findOne(@RequestParam Integer id) {
		return userRepository.findById(id);
	}

	@GetMapping(path = "/delete")

	public void delete(@RequestParam Integer id) {
		userRepository.deleteById(id);
	}
}
````
然后启动运行就可以直接看效果了。
###2.4 PagingAndSortingRepository方法详解
通过类的关系图，我们可以看到PagingAndSortingRepository继承CrudRepository所以他的基本方法，它都有增加了分页和排序等对查询结果进行限制的一些基本的，常用的，通用的一些分页方法。
####2.4.1 PagingAndSortingRepository interface 内容
> 一样，我们也来查看一下PagingAndSortingRepository的源码看看帮我们提供了哪些方法。

````
package org.springframework.data.repository;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Sort;
@NoRepositoryBean
public interface PagingAndSortingRepository<T, ID> extends CrudRepository<T, ID> {
	Iterable<T> findAll(Sort sort); （1）
	Page<T> findAll(Pageable pageable); （2）
}
````
- (1)根据排序取所有的对象的集合。
- (2)根据分页和排序进行查询，并用Page对象封装。Pageable对象包含分页和Sort对象。
PagingAndSortingRepository和CrudRepository都是spring data common的标准接口，如果我们采用jpa那它对应的实现类就是spring data jpa的model里面的SimpleJpaRepository。如果是其它nosql的实现mongodb。那它的实现就在spring data mongodb的model里面。    
我来看一下page查询的实现内容如下：

````
	public Page<T> findAll(Pageable pageable) {
		if (isUnpaged(pageable)) {
			return new PageImpl<T>(findAll());
		}
		return findAll((Specification<T>) null, pageable);
	}
````
我们看源码发现这些查询都会用到我们后面章节要讲的Specification查询方法。

#### 2.4.2 PagingAndSortingRepository使用案例
也是只需要继承PagingAndSortingRepository的接口即可。其它不要做任何改动。UserPagingAndSortingRepository修改如下：

````
package com.example.example2.repository;
import com.example.example2.entity.User;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.repository.PagingAndSortingRepository;
public interface UserPagingAndSortingRepository extends PagingAndSortingRepository<User,Long> {
	Page<User> findByName(String name, Pageable pageable) throws Exception;
}
````
UserController修改如下：

````
@Controller
@RequestMapping(path = "/demo")
public class UserController {
	/**
	 * 验证排序和分页查询方法，Pageable的默认实现类：PageRequest
	 * @return
	 */
	@GetMapping(path = "/page")
	@ResponseBody
	public Page<User> getAllUserByPage() {
		return userPagingAndSortingRepository.findAll(
				new PageRequest(1, 20,new Sort(new Sort.Order(Sort.Direction.ASC,"name"))));
	}
	/**
	 * 排序查询方法，使用Sort对象
	 * @return
	 */
	@GetMapping(path = "/sort")
	@ResponseBody
	public Iterable<User> getAllUsersWithSort() {
		return userPagingAndSortingRepository.findAll(new Sort(new Sort.Order(Sort.Direction.ASC,"name")));
	}
}
````
### 2.5 JpaRepository方法详解
#### 2.5.1 JpaRepository详解
JpaRepository到这里可以进入到分水岭了，上面的那些都是spring data为了兼容nosql而进行的一些抽象封装，而从JpaRepository开始是对关系型数据库进行抽象封装。从类图可以看得出来它继承PagingAndSortingRepository类，也就继承了其所有方法，并且其实现类也是SimpleJpaRepository。从类图上还可以看出JpaRepository继承和拥有了QueryByExampleExecutor的相关方法。而QueryByExampleExecutor的详细用法我们会在后面的章节中详细介绍，我们先来来一下JpaRepository有哪些方法：

````
package org.springframework.data.jpa.repository;

import java.util.List;

import javax.persistence.EntityManager;

import org.springframework.data.domain.Example;
import org.springframework.data.domain.Sort;
import org.springframework.data.repository.NoRepositoryBean;
import org.springframework.data.repository.PagingAndSortingRepository;
import org.springframework.data.repository.query.QueryByExampleExecutor;

/**
 * JPA specific extension of {@link org.springframework.data.repository.Repository}.
 *
 * @author Oliver Gierke
 * @author Christoph Strobl
 * @author Mark Paluch
 */
@NoRepositoryBean
public interface JpaRepository<T, ID> extends PagingAndSortingRepository<T, ID>, QueryByExampleExecutor<T> {

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.repository.CrudRepository#findAll()
	 */
	List<T> findAll();

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.repository.PagingAndSortingRepository#findAll(org.springframework.data.domain.Sort)
	 */
	List<T> findAll(Sort sort);
	List<T> findAllById(Iterable<ID> ids);
	<S extends T> List<S> saveAll(Iterable<S> entities);
	void flush();
	<S extends T> S saveAndFlush(S entity);
	void deleteInBatch(Iterable<T> entities);
	void deleteAllInBatch();
	T getOne(ID id);
	<S extends T> List<S> findAll(Example<S> example);
	<S extends T> List<S> findAll(Example<S> example, Sort sort);
}
````
通过源码和CrudRepository相比较支持了Query By Example，批量删除，提高删除效率，手动刷新数据库的更改方法。将默认实现的查询结果变成了List。
####2.5.2 JpaRepository使用方法也一样，只需要继承它即可。如下面的例子：

````
package com.example.example2.repository;
import com.example.example2.entity.User;
import org.springframework.data.jpa.repository.JpaRepository;
public interface UserJpaRepository extends JpaRepository<User,Long> {
}
````
###2.6 Repository的实现类SimpleJpaRepository
SimpleJpaRepository是JPA整个关联数据库的所有Repository的接口实现类。如果想进行扩展，可以继承此类，如QueryDsl的扩展。还有默认的处理机制。如果将此类里面的实现方法看透了，基本上jpa的api就能掌握大部分。同时也是spring jpa的动态代理的实现类，包括我们后面讲的Query Method。
我们可以通过Debug试图，看一下动态代理过程，如图：
![enter image description here](http://images.gitbook.cn/368a3460-2abe-11e8-acca-d972d7a925f0)
SimpleJpaRepository的部分源码如下：  

````
@Repository
@Transactional(readOnly = true)
public class SimpleJpaRepository<T, ID> implements JpaRepository<T, ID>, JpaSpecificationExecutor<T> {
	private static final String ID_MUST_NOT_BE_NULL = "The given id must not be null!";
	private final JpaEntityInformation<T, ?> entityInformation;
	private final EntityManager em;
	private final PersistenceProvider provider;
	private @Nullable CrudMethodMetadata metadata;
	......
	@Transactional
	public void deleteAllInBatch() {
		em.createQuery(getDeleteAllQueryString()).executeUpdate();
	}
	......
````
可以看出SimpleJpaRepository的实现机制还挺清晰的，通过EntityManger进行实体的操作，JpaEntityInforMation里面存着实体的相关信息，还有crud方法的元数据等等，后面章节我们还经常提到此类，慢慢讲解。








