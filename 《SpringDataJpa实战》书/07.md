## 第07课：JpaRepository 扩展之 JpaSpecificationExecutor
### 7.1 JpaSpecificationExecutor介绍
通过前面的几节，我们其实大部分的简单场景可以满足，但是一个orm的解决方案绝不能拘泥与简单方案，而JpaSpecificationExecutor是JPA2.0提供的Criteria API的使用的封装，可以用于动态生成query来满足我们业务中的各种复杂场景。spring data jpa为我们提供了JpaSpecificationExecutor接口，只要简单实现toPredicate方法就可以实现复杂的查询。
### 7.2 JpaSpecificationExecutor使用方法
#### 7.2.1 JpaSpecificationExecutor源码和API
![enter image description here](http://images.gitbook.cn/c5b05b30-397b-11e8-9769-ad5a3e0d00fa)
我们也可以同通过idea工具详细看其用法和实现类JpaSpecificationExecutor是我们的Repository要继承的接口，而SimpleJpaRepository是其的默认实现。而通过源码来看其实其提供的api比较简单、明了，详细看一下如下几个方法：

````
public interface JpaSpecificationExecutor<T> {
   //根据Specification条件查询单个对象，注意的是，如果条件能查出来多个会报错
   T findOne(@Nullable Specification<T> spec);
   //根据Specification条件查询List结果
   List<T> findAll(@Nullable Specification<T> spec);
   //根据Specification条件，分页查询
   Page<T> findAll(@Nullable Specification<T> spec, Pageable pageable);
   //根据Specification条件，带排序的查询结果
   List<T> findAll(@Nullable Specification<T> spec, Sort sort);
   //根据Specification条件，查询数量。
   long count(@Nullable Specification<T> spec);
}
````
不难看的出来，这个接口基本是围绕着Specification接口来定义的。我们先来看下其源码：
![enter image description here](http://images.gitbook.cn/2b0572c0-397e-11e8-9f33-a7686c32808c)
我们仔细看看图，就会发现Specifications的接口的实现类就三个。
````
/**
 * Specifications是Spring Data Jpa对Specification的聚合操作工具类，里面有以下四个方法：
*/
@Deprecated  //已经不推荐使用了，我们可以用Specification来代替，如上图。
public class Specifications<T> implements Specification<T>, Serializable {
   private final Specification<T> spec;
   //构造方法私有化，只能通过where/not创建Specifications对象。
   private Specifications(Specification<T> spec) {
      this.spec = spec;
   }
   //创建where后面的Predicate集合
   public static <T> Specifications<T> where(Specification<T> spec) {
      return new Specifications<T>(spec);
   }
   //创建not集合的Predicate
   public static <T> Specifications<T> not(Specification<T> spec) {
      return new Specifications<T>(new NegatedSpecification<T>(spec));
   }
   //Specification的and关系集合
   public Specifications<T> and(Specification<T> other) {
      return new Specifications<T>(new ComposedSpecification<T>(spec, other, AND));
   }
   //Specification的or关系集合
   public Specifications<T> or(Specification<T> other) {
      return new Specifications<T>(new ComposedSpecification<T>(spec, other, OR));
   }
......
}
````
而我们如果查看Specifications源码的话就会发现，其已经将来要被删除了，已经不推荐使用了，而另外两个都是局部私有的。所以我们真正关注的就是Specification接口中如下一个接口方法：

````
public interface Specification<T> {
   Predicate toPredicate(Root<T> root, CriteriaQuery<?> query, CriteriaBuilder cb);
}
````
从这里可以看出，而我们的每个调用的地方都需要，创建Specification的实现类。而JpaSpecificationExecutor是针对Criteria API进行了predicate标准封装，帮我们封装了通过EntityManager的查询和使用细节，使操作Criteria更加便利了一些。所以我们要掌握一下Predicate、Root、CriteriaQuery、CriteriaBuilder是什么鬼？
#### 7.2.2 Criteria的概念简单介绍
***1）Root<T> root：***    

代表了可以查询和操作的实体对象的根。如果将实体对象比喻成表名，那root里面就是这张表里面的字段。这不过是JPQL的实体字段而已。通过里面的Path<Y> get(String attributeName)，来获得我们像操作的字段。   

***2）CriteriaQuery<?> query：***    
代表一个specific的顶层查询对象，它包含着查询的各个部分，比如：`select 、from、where、group by、order by`等。CriteriaQuery对象只对实体类型或嵌入式类型的Criteria查询起作用，简单理解，它提供了查询ROOT的方法。常用的方法有：

````
CriteriaQuery<T> where(Predicate... restrictions);
CriteriaQuery<T> select(Selection<? extends T> selection);
CriteriaQuery<T> having(Predicate... restrictions);
````
***3）CriteriaBuilder cb：***

用来构建CritiaQuery的构建器对象，其实就相当于条件或者是条件组合，以谓语即Predicate的形式返回。构建简单的Predicate示例：

````
Predicate p1=cb.like(root.get(“name”).as(String.class), “%”+uqm.getName()+“%”);
Predicate p2=cb.equal(root.get("uuid").as(Integer.class), uqm.getUuid());
Predicate p3=cb.gt(root.get("age").as(Integer.class), uqm.getAge());
````
构建组合的Predicate示例：   
`Predicate p = cb.and(p3,cb.or(p1,p2));`      

***4）实际经验：***  
到此我们发现其实JpaSpecificationExecutor帮我提供了一个高级的入口和结构，通过这个入口，可以使用底层JPA的Criteria所有方法，其实就可以满足了所有业务场景。但实际工作中，需要注意的是，如果一旦我们写的实现逻辑太复杂，第二个人一般来看不懂的时候，那一定是有问题的，我要寻找更简单的，更易懂的，更优雅的方式。比如：   

1. 分页和排序我们就没有比较自己再去实现一遍逻辑，直接用其开放的Pageable和Sort即可。
1. 当我们过多的使用group或者having，sum，count等内置的sql函数的时候，我们想想就是我们通过Specification实现了逻辑，这种效率真的高吗？是不是数据在其他算好更好。
1. 当我们过多的操作left join和inner Join的链表查询的时候，我们想想，是不是通过数据库的视图(view)更优雅一点。

####7.3 JpaSpecificationExecutor使用案例
######1）新建两个实体

````
@Entity(name = "UserInfoEntity")
@Table(name = "user_info", schema = "test")
public class UserInfoEntity  implements Serializable {
   @Id
   @Column(name = "id", nullable = false)
   private Integer id;
   @Column(name = "first_name", nullable = true, length = 100)
   private String firstName;
   @Column(name = "last_name", nullable = true, length = 100)
   private String lastName;
   @Column(name = "telephone", nullable = true, length = 100)
   private String telephone;
   @Column(name = "create_time", nullable = true)
   private Date createTime;
   @Column(name = "version", nullable = true)
   private String version;
   @OneToOne(optional = false,fetch = FetchType.EAGER)
   @JoinColumn(referencedColumnName = "id",name = "address_id",nullable = false)
   @Fetch(FetchMode.JOIN)
   private UserReceivingAddressEntity addressEntity;
......
}
````
````
@Entity
@Table(name = "user_receiving_address", schema = "test")
public class UserReceivingAddressEntity  implements Serializable {
   @Id
   @Column(name = "id", nullable = false)
   private Integer id;
   @Column(name = "user_id", nullable = false)
   private Integer userId;
   @Column(name = "address_city", nullable = true, length = 500)
   private String addressCity;
......
}
````
######2）UserRepository需要继承JpaSpecificationExecutor

````
public interface UserRepository extends JpaSpecificationExecutor<UserInfoEntity> {
}
````
######3）调用者UserInfoManager的写法。
- 我们演示一下直接用lambda使用Root<T>和CriteriaBuilder做一个简单的不同条件的查询和链表查询。 

````
@Component
public class UserInfoManager {
   @Autowired
   private UserRepository userRepository;
   public Page<UserInfoEntity> findByCondition(UserInfoRequest userParam,Pageable pageable){
      return userRepository.findAll((root, query, cb) -> {
         List<Predicate> predicates = new ArrayList<Predicate>();
         if (StringUtils.isNoneBlank(userParam.getFirstName())){
            //liked的查询条件
            predicates.add(cb.like(root.get("firstName"),"%"+userParam.getFirstName()+"%"));
         }
         if (StringUtils.isNoneBlank(userParam.getTelephone())){
            //equal查询条件
            predicates.add(cb.equal(root.get("telephone"),userParam.getTelephone()));
         }
         if (StringUtils.isNoneBlank(userParam.getVersion())){
            //greaterThan大于等于查询条件
            predicates.add(cb.greaterThan(root.get("version"),userParam.getVersion()));
         }
         if (userParam.getBeginCreateTime()!=null&&userParam.getEndCreateTime()!=null){
            //根据时间区间去查询   predicates.add(cb.between(root.get("createTime"),userParam.getBeginCreateTime(),userParam.getEndCreateTime()));
         }
         if (StringUtils.isNotBlank(userParam.getAddressCity())) {
            //联表查询，利用root的join方法，根据关联关系表里面的字段进行查询。
            predicates.add(cb.equal(root.join("addressEntityList").get("addressCity"), userParam.getAddressCity()));
         }
         return query.where(predicates.toArray(new Predicate[predicates.size()])).getRestriction();
      }, pageable);
   }
}
//可以仔细体会上面这个案例，实际工作中应该大部分都是这种写法，就算扩展也是百变不离其中。
````

- 我们再来看一个不常见的复杂查询的写法，来展示一下CriteriaQuery的用法。（作者已经强烈不推荐了哦，和上面比起来太不优雅了）

````
public List<MessageRequest> findByConditions(String name, Integer price, Integer stock) {  
        messageRequestRepository.findAll((Specification<MessageRequest>) (itemRoot, query, criteriaBuilder) -> {
            //这里用List存放多种查询条件,实现动态查询
            List<Predicate> predicatesList = new ArrayList<>();
            //name模糊查询 ,like语句
            if (name != null) {
                predicatesList.add(
                    criteriaBuilder.and(
                        criteriaBuilder.like(
                            itemRoot.get("name"), "%" + name + "%")));
            }
            // itemPrice 小于等于 <= 语句
            if (price != null) {
                predicatesList.add(
                    criteriaBuilder.and(
                        criteriaBuilder.le(
                            itemRoot.get("price"), price)));
            }
            //itemStock 大于等于 >= 语句
            if (stock != null) {
                predicatesList.add(
                    criteriaBuilder.and(
                        criteriaBuilder.ge(
                            itemRoot.get("stock"), stock)));
            }
            //where()拼接查询条件
            query.where(predicatesList.toArray(new Predicate[predicatesList.size()]));
            //返回通过CriteriaQuery拼装的 Predicate
            return query.getRestriction();
        });
    }
````

- 而没有Spring Data JPA封装之前,如果想获得此三个对象 Root<T> root, CriteriaQuery<?> query, CriteriaBuilder criteriaBuilder，老式Hibernate的写法如下：（PS:强烈不推荐哦，虽然现在也支持，只是让大家知道一下。）


````
@Autowired //导入entityManager
 private EntityManager entityManager;
//创建CriteriaBuilder安全查询工厂，CriteriaBuilder是一个工厂对象,安全查询的开始.用于构建JPA安全查询.
CriteriaBuilder criteriaBuilder = entityManager.getCriteriaBuilder();
//创建CriteriaQuery安全查询主语句
//CriteriaQuery对象必须在实体类型或嵌入式类型上的Criteria 查询上起作用。
CriteriaQuery<Item> query = criteriaBuilder.createQuery(Item.class);
//Root 定义查询的From子句中能出现的类型
Root<Item> itemRoot = query.from(Item.class);
````

- 我们再来看一个利用CriteriaQuery例子，其实大家可以扩展一下思路，就是Hibernate那套在这里面都支持,不过作者还是建议代码越简单越好。

````
		List<UserSpuFavoriteEntity> result = userSpuFavoriteDao.findAll((Root<UserSpuFavoriteEntity> root, CriteriaQuery<?> query, CriteriaBuilder cb)->{
			query.where(cb.and(cb.equal(root.get("userName"), userName),cb.isFalse(root.get("isDelete"))));
			query.orderBy(cb.desc(root.get("updateTime")));
			return query.getRestriction();
		});
````
####7.4 Specification工作中的一些扩展
我们在实际工作中会发现，如果上面的逻辑，简单重复写总感觉是不是可以抽出一些公用方法呢，此时我们引入一种工厂模式，帮我们做一些事情，可以让我们的代码更加优雅。基于JpaSpecificationExecutor的思路，我们创建一个SpecificationFactory.Java内容如下：

````
public final class SpecificationFactory {
   /**
    * 模糊查询，匹配对应字段
    */
   public static Specification containsLike(String attribute, String value) {
      return (root, query, cb)-> cb.like(root.get(attribute), "%" + value + "%");
   }
   /**
    * 某字段的值等于value的查询条件
    */
   public static Specification equal(String attribute, Object value) {
      return (root, query, cb) -> cb.equal(root.get(attribute),value);
   }
   /**
    * 获取对应属性的值所在区间
    */
   public static Specification isBetween(String attribute, int min, int max) {
      return (root, query, cb) -> cb.between(root.get(attribute), min, max);
   }
   public static Specification isBetween(String attribute, double min, double max) {
      return (root, query, cb) -> cb.between(root.get(attribute), min, max);
   }
   public static Specification isBetween(String attribute, Date min, Date max) {
      return (root, query, cb) -> cb.between(root.get(attribute), min, max);
   }
   /**
    * 通过属性名和集合实现in查询
    */
   public static Specification in(String attribute, Collection c) {
      return (root, query, cb) ->root.get(attribute).in(c);
   }
   /**
    * 通过属性名构建大于等于Value的查询条件
    */
   public static Specification greaterThan(String attribute, BigDecimal value) {
      return (root, query, cb) ->cb.greaterThan(root.get(attribute),value);
   }
   public static Specification greaterThan(String attribute, Long value) {
      return (root, query, cb) ->cb.greaterThan(root.get(attribute),value);
   }
......
}
````
>ps: 可以根据实际工作需要和场景进行不断扩充。

###### 调用实例1：

````
userRepository.findAll(
      SpecificationFactory.containsLike("firstName", userParam.getLastName()),
      pageable);
````
是不是可以发现代码一下子少了很多？
###### 配合Specifications使用，调用实例2：

````
userRepository.findAll(Specifications.where(
      SpecificationFactory.containsLike("firstName", userParam.getLastName()))
            .and(SpecificationFactory.greaterThan("version",userParam.getVersion())),
      pageable);
````
和我们前面举得例子比起来是不是代码更加优雅，可读性更加强了。

####7.5 JpaSpecificationExecutor实现原理
#####1）我们还是先通过开发工具，把关键的类添加到Diagram上面进行分析，如图：
![enter image description here](http://images.gitbook.cn/b22ffc50-397b-11e8-9f33-a7686c32808c)
我们通过上图可以看一下，我们前面介绍的几个类之间的关联关系。
#####2）SimpleJpaRepository实现类中的关键源码如下：
````
/**
 *以findOne为例
*/
public T findOne(Specification<T> spec) {
   try {
      return getQuery(spec, (Sort) null).getSingleResult();
   } catch (NoResultException e) {
      return null;
   }
}
/*
 * 解析Specification，利用EntityManager直接实现调用逻辑。
*/
protected <S extends T> TypedQuery<S> getQuery(Specification<S> spec, Class<S> domainClass, Sort sort) {
   CriteriaBuilder builder = em.getCriteriaBuilder();
   CriteriaQuery<S> query = builder.createQuery(domainClass);
   Root<S> root = applySpecificationToCriteria(spec, domainClass, query);
   query.select(root);
   if (sort != null) {
      query.orderBy(toOrders(sort, root, builder));
   }
   return applyRepositoryMethodMetadata(em.createQuery(query));
}
````
其实我们可以看的出来底层都是调用的EntityManager。
#####3) 与EntityManager的关系图 
![enter image description here](http://images.gitbook.cn/f0cc4580-3986-11e8-9b9a-53206b7f130d) 
通过此图我们可以体会一下Repository和EntityManager的关联关系。
> 其实在实际项目中，我们的Repository可以扩展的更加优雅一点来解决后台api的search问题和如何自定义Respository?     
> 欢迎大家进入 QQ交流群1：240619787 和QQ交流群2：559701472 或者作者的读者圈，共同探讨问题。