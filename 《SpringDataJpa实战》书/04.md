##第四章 注解式查询方法
>本章详细讲解，声明式的查询方法，即注解的查询用法大全。这种也是平时工作中最常见的用法。

![enter image description here](http://images.gitbook.cn/b7bad320-2dcd-11e8-929f-9f2bcc393f42)   
我们先看一下大纲，上图@开头的基本上就是咱们必须要熟悉掌握的注解。而中间的SpEL是Spring的表达式在其注解中有支持。关于SpEL的详细讲解有兴趣的读者可以看作者的另一篇Chat。  
###4.1 @Query详解
####4.1.1先看一下语法及其源码：

````
public @interface Query {
   /**
    * 指定JPQL的查询语句。（nativeQuery=true的时候，是原生的Sql语句）
	*/
   String value() default "";
   /**
	* 指定count的JPQL语句，如果不指定将根据query自动生成。
    * （如果当nativeQuery=true的时候，指的是原生的Sql语句）
    */
   String countQuery() default "";
   /**
    * 根据哪个字段来count，一般默认即可。
	*/
   String countProjection() default "";
   /**
    * 默认是false，表示value里面是不是原生的sql语句
	*/
   boolean nativeQuery() default false;
   /**
    * 可以指定一个query的名字，必须唯一的。
	* 如果不指定，默认的生成规则是：
    * {$domainClass}.${queryMethodName}
    */
   String name() default "";
   /*
    * 可以指定一个count的query的名字，必须唯一的。
	* 如果不指定，默认的生成规则是：
    * {$domainClass}.${queryMethodName}.count
    */
   String countName() default "";
}
````
#### 4.1.2@Query用法
使用命名查询为实体声明查询是一种有效的方法，对于少量查询很有效。一般只需要关心@Query里面的value和nativeQuery的值。使用声明式JPQL查询有个好处，就是启动的时候就知道你的语法正确不正确。`ps:好的架构师写代码的报错的顺序是编译<启动<运行时。即越早发现错误越好。`默认value里面是JPQL语法，既对象查询和sql、hql比较类似。          
案例4.1：声明一个注解在Repository的查询方法上  

````
public interface UserRepository extends JpaRepository<User, Long>{
  @Query("select u from User u where u.emailAddress = ?1")
  User findByEmailAddress(String emailAddress);
}
````
案例4.2：Like查询，注意firstname不会自动加上%关键字的

````
public interface UserRepository extends JpaRepository<User, Long> {
  @Query("select u from User u where u.firstname like %?1")
  List<User> findByFirstnameEndsWith(String firstname);
}
````
案例4.3：直接用原始SQL

````
public interface UserRepository extends JpaRepository<User, Long> {
  @Query(value = "SELECT * FROM USERS WHERE EMAIL_ADDRESS = ?1", nativeQuery = true)
  User findByEmailAddress(String emailAddress);
}
````
>注意：nativeQuery不支持直接Sort的参数查询。

````
案例4.4：nativeQuery的排序错误的写法，下面这个是启动不起来的。

````
public interface UserRepository extends JpaRepository<User, Long> {
@Query(value = "select * from user_info where first_name=?1",nativeQuery = true)
List<UserInfoEntity> findByFirstName(String firstName,Sort sort);
}
````
案例4.5：nativeQuery的排序的写法。

````
@Query(value = "select * from user_info where first_name=?1 order by ?2",nativeQuery = true)
List<UserInfoEntity> findByFirstName(String firstName,String sort);
//调用的地方写法last_name是数据里面的字段名，不是对象的字段名
repository.findByFirstName("jackzhang","last_name");
````
#### 4.1.3 @Query的排序
@Query的JPQL情况下，想实现排序，方法上面直接用PageRequest或者直接用Sort参数都可以做到。     
在排序实例中实际使用的属性需要与实体模型里面的字段相匹配，这意味着它们需要解析为查询中使用的属性或别名。这是一个state_field_path_expression JPQL定义。并且Sort的对象支持一些特定的函数。    
案例4.6 Sort and JpaSort的使用

````
public interface UserRepository extends JpaRepository<User, Long> {
  @Query("select u from User u where u.lastname like ?1%")
  List<User> findByAndSort(String lastname, Sort sort);
  @Query("select u.id, LENGTH(u.firstname) as fn_len from User u where u.lastname like ?1%")
  List<Object[]> findByAsArrayAndSort(String lastname, Sort sort);
}
//调用方的写法，如下：
repo.findByAndSort("lannister", new Sort("firstname"));               
repo.findByAndSort("stark", new Sort("LENGTH(firstname)"));          
repo.findByAndSort("targaryen", JpaSort.unsafe("LENGTH(firstname)"));
repo.findByAsArrayAndSort("bolton", new Sort("fn_len"));   
````
#### 4.1.4 @Query的分页   
案例4.7  直接用Page对象接受接口，参数直接用Pageable的实现类即可。

````
public interface UserRepository extends JpaRepository<User, Long> {
  @Query(value = "select u from User u where u.lastname = ?1")
  Page<User> findByLastname(String lastname, Pageable pageable);
}
//调用者的写法
repository.findByFirstName("jackzhang",new PageRequest(1,10));
````
案例4.8 对原生sql的分页支持，案例如下，但是支持的不是特别友好，以mysql为例。

````
 public interface UserRepository extends JpaRepository<UserInfoEntity, Integer>, JpaSpecificationExecutor<UserInfoEntity> {
   @Query(value = "select * from user_info where first_name=?1 /* #pageable# */",
         countQuery = "select count(*) from user_info where first_name=?1",
         nativeQuery = true)
   Page<UserInfoEntity> findByFirstName(String firstName, Pageable pageable);
}
//调用者的写法
return userRepository.findByFirstName("jackzhang",new PageRequest(1,10, Sort.Direction.DESC,"last_name"));
//打印出来的sql
select  *   from  user_info  where  first_name=? /* #pageable# */  order by  last_name desc limit ?, ?
````
>注意：1：这个注释/* #pageable# */必须有；   
>2：估计有可能随着版本的变化这个会做优化。   
>3：另外一种实现方法就是自己写两个查询方法，自己手动分页。

### 4.2 @Param用法：
默认情况下，参数是通过顺序绑定在查询语句上的。这使得查询方法对参数位置的重构容易出错。为了解决这个问题，你可以使用@ Param注解指定方法参数的具体名称，通过绑定的参数名字做查询条件。这样不需要关心参数的顺序，推荐这种做法，比较利于代码重构。    
案例4.9 根据参数进行查询  

````
public interface UserRepository extends JpaRepository<User, Long> {
  @Query("select u from User u where u.firstname = :firstname or u.lastname = :lastname")
  User findByLastnameOrFirstname(@Param("lastname") String lastname,
                                 @Param("firstname") String firstname);
}
````   
案例4.10 根据参数进行查询，top 10 前面说的query method关键字照样有用,如下：  

````
public interface UserRepository extends JpaRepository<User, Long> {
  @Query("select u from User u where u.firstname = :firstname or u.lastname = :lastname")
  User findTop10ByLastnameOrFirstname(@Param("lastname") String lastname,
                                 @Param("firstname") String firstname);
}
````
>提醒：大家通过@Query定义自己的查询方法的时候建议也用Spring Data JPA的name query的命名方法，这样下来风格就比较统一了。

###4.3 Spel表达式的支持
在Spring Data JPA 1.4以后，支持在@Query中使用SpEL表达式(简介)来接收变量。 
SpEL支持的变量：    

变量名 | 使用方式 | 描述 
--- | --- | ---
entityName | select x from #{#entityName} x | 根据指定的Repository自动插入相关的entityName。

>有两种方式能被解析出来：       
>1）如果定了了@Entity注解，直接用其属性名。      
>2）如果没定义，直接用实体的类的名称   

以下的例子中，我们在查询语句中插入表达式：

````
@Entity("User")
public class User {
   @Id
   @GeneratedValue
   Long id;
   String lastname;
}
//Repository写法
public interface UserRepository extends JpaRepository<User, Long> {
   @Query("select u from #{#entityName} u where u.lastname = ?1")
   List<User> findByLastname(String lastname);
}
````
这个SPEL的支持，比较适合自定义的Repository，如果想写一个通用的Repository接口，那么可以用这个表达式来处理：

````
@MappedSuperclass
public abstract class AbstractMappedType {
   …
   String attribute;
}
@Entity
public class ConcreteType extends AbstractMappedType { …
}
@NoRepositoryBean
public interface MappedTypeRepository<T extends AbstractMappedType> extends Repository<T, Long> {
   @Query("select t from #{#entityName} t where t.attribute = ?1")
   List<T> findAllByAttribute(String attribute);
}
public interface ConcreteRepository extends MappedTypeRepository<ConcreteType> { …
}
````
MappedTypeRepository作为一个公用的父类，自己的Repository可以继承它，当调用ConcreteRepository执行findAllByAttribute方法的时候执行结果如下：

````
select t from ConcreteType t where t.attribute = ?1
````
### 4.4 @Modifying修改查询
学习思路一样，我们先看源码：

````
public @interface Modifying {
//如果配置了一级缓存，这个时候用clearAutomatically=true,就会刷新hibernate的一级缓存了， 不然你在同一接口中，更新一个对象，接着查询这个对象，那么你查出来的这个对象还是之前的没有更新之前的状态。这个比较适合老Hibernate的开发的程序员。
    boolean clearAutomatically() default false;
}
````
您可以通过在@Modifying注解实现只需要参数绑定的update查询的执行。我们来看个例子根据lastName更新firstname并且返回更新条数如下：

````
@Modifying
@Query("update User u set u.firstname = ?1 where u.lastname = ?2")
int setFixedFirstnameFor(String firstname, String lastname);
````
简单的针对某些特定属性的更新，也可以直接用基类里面提供的通用save来做更新(即：继承CrudRepository接口)。   

##### 还有第三种方法就是自定义Repository使用EntityManager来进行更新操作。
对删除操作的支持如下：

````
interface UserRepository extends Repository<User, Long> {
  void deleteByRoleId(long roleId);
  @Modifying
  @Query("delete from User u where user.role.id = ?1")
  void deleteInBulkByRoleId(long roleId);
}
````
所以现在我们一共有四种方式来做更新操作：   

1. 是通过方法表达式（method name query），上章讲的。
2. 还有一种就是@Modifying注解。
3. @Query注解也可以做到。
4. 继承CrudRepository接口。

####4.5 @QueryHints
有很多数据库支持Hint Query的语法，不过这种查询支持比较老旧，感觉应该会慢慢被淘汰，工作中很少见有人使用的。但Spring Data Jpa还是做了很好的支持，但是它只支持一些固定的HintValue值，用来优化query的作用。有两个注解需要了知道@QueryHints,value等于多个@QueryHint。      
用法如下：

````
public interface UserRepository extends Repository<User, Long> {
  @QueryHints(value = { @QueryHint(name = "name", value = "value")},
              forCounting = false)
  Page<User> findByLastname(String lastname, Pageable pageable);
}
````
而@QueryHint其中的name是固定的在类QueryHints当中，只能到这里面选。我们看一下QueryHints的源码：

````
package org.hibernate.jpa;
.......
public class QueryHints {
    //指定此处查询的超时时间，毫秒
    public static final String SPEC_HINT_TIMEOUT = TIMEOUT_JPA;
    //支持数据的comment的hint提示语法
    public static final String HINT_COMMENT = COMMENT;
    //每次fetch的大小
    public static final String HINT_FETCH_SIZE = FETCH_SIZE;
    //是否开启缓存，需要配合一级缓存使用，不建议用。
    public static final String HINT_CACHEABLE = CACHEABLE;
    public static final String HINT_CACHE_REGION = CACHE_REGION;
    //是否只读
    public static final String HINT_READONLY = READ_ONLY;
    public static final String HINT_CACHE_MODE = CACHE_MODE;
    public static final String HINT_FLUSH_MODE = FLUSH_MODE;
    public static final String HINT_NATIVE_LOCKMODE = NATIVE_LOCKMODE;
    public static final String HINT_FETCHGRAPH = FETCHGRAPH;
    //配置 EntityGraph的两种值FetchType.LAZY或者 FetchType.EAGER
    public static final String HINT_LOADGRAPH = LOADGRAPH;
   .......
}
````
QueryHint紧紧作了解就行了，一般的业务场景基本上用不上。
#### 4.6 @Procedure储存过程的查询方法
>我们通过@Procedure来介绍一下，jpa对储存过程的支持。

#####1）@Procedure源码如下：

````
public @interface Procedure {
   // 数据库里面储存过程的名称
   String value() default "";
   // 数据库里面储存过程的名称
   String procedureName() default "";
   //在EntityManager中的名字，NamedStoredProcedureQuery使用
   String name() default "";
   //输出参数的名字
   String outputParameterName() default "";
}
````
##### 2）首先创建一个储存过程名字叫plus1inout有两个参数，两个结果。

````
CREATE PROCEDURE plus1inout(IN arg int, OUT res int)
BEGIN
 SELECT (arg+10) into res;
END
````
##### 3）我们可以使用@NamedStoredProcedureQueries注释来调用存储过程。这个必须定义在一个实体上面。

````
@Entity
@NamedStoredProcedureQuery(name = "User.plus1", procedureName = "plus1inout", parameters = {
@StoredProcedureParameter(mode = ParameterMode.IN, name = "arg", type = Integer.class),
@StoredProcedureParameter(mode = ParameterMode.OUT, name = "res", type = Integer.class) })
public class User {
   //这个是一个Procedure实体类，可以通过NamedStoredProcedureQueries在这个类里面定义多个储存过程的查询。
}
````
关键要点：   

-  存储过程使用了注释@NamedStoredProcedureQuery，并绑定到一个JPA表。
-  procedureName是存储过程的名字
-  name是JPA中的存储过程的名字
-  使用注释@StoredProcedureParameter来定义存储过程使用的IN/OUT参数

##### 4）直接通过自定义过的Repository完成储存过程的调用

````
public interface MyUserRepository extends CrudRepository<User, Long> {
@Procedure("plus1inout")//通过储存过程的名字
Integer explicitlyNamedPlus1inout(Integer arg);
@Procedure(procedureName = "plus1inout")//通过储存过程的名字
Integer plus1inout(Integer arg);
@Procedure(name = "User.plus1IO")//自定义的储存过程的名字
Integer entityAnnotatedCustomNamedProcedurePlus1IO(@Param("arg") Integer arg);
}
````
关键要点：

  - @Procedure的procedureName参数必须匹配@NamedStoredProcedureQuery的procedureName
  - @Procedure的name参数必须匹配@NamedStoredProcedureQuery的name
  - @Param必须匹配@StoredProcedureParameter注释的name参数
  - 返回类型必须匹配：in_only_test存储过程返回是void，in_and_out_test存储过程必须返回String

###4.7 @NamedQueries预定义查询
#### 4.7.1 这种是预定义查询的一种形式。
#####1）在@Entity下增加@NamedQuery定义。

````
public @interface NamedQuery {
   //query的名称，规则：实体.方法名；
   String name();
   //具体的JPQL查询语法
   String query();
}
````
需要注意，这里的query里面的值也是JPQL。查询参数也要和实体进行对应起来。因为实际场景
中这种破坏Entity的侵入式很不美感，也不方便，所以这种方式容易遗忘，工作中也很少推荐的一种方式。
##### 2）与之相对应的还有@NamedNativeQuery。用法一样，唯一不一样的是，query里面放置的是原生sql语句，而非实体的字段名字。
####4.7.2 用法举例：
1)实体里面的写法

````
@Entity
@NamedQuery(name="Customer.findByFirstName",query = "select c from Customer c where c.firstName = ?1")
public class Customer {
   @Id
   @GeneratedValue(strategy = GenerationType.AUTO)
   private Long id;
   private String firstName;
   private String lastName;
......
}
````
2）CustomerRepository里面的写法

````
Customer findByFirstName(String bauer);
````
3）调用者的写法

````
Customer customer = repository.findByFirstName("Bauer");
````
####4.7.3 @NamedQuery和@Query、方法定义查询三者对比。

1. Spring Jpa里面的有先级，咱们前面章节有讲到过：@Query > @NameQuery > 方法定义查询。
2. 推荐使用的有优先级：@Query > 方法定义查询 > @NameQuery。
3. 相同点，都不支持动态条件查询。

###4.8 @Query的优缺点与实战经验分享

分类|描述|
--- | ---
优点 | 1.可以灵活快速的使用JPQL和SQL  
    | 2. 对返回的结果和字段记性自定义
    | 3. 支持连表查询和对象关联查询，可以组合出来复杂的sql或者JPQL
    | 4. 可以很好的表达你的查询思路。
    | 5. 灵活性非常强，快捷方便。
缺点 | 1.不支持动态查询条件,参数个数如果是不固定的不支持。
    | 2.有些同学会将返回结果用Map或者Object[]数组接收结果，会导致调用的人不知道里面有什么东西。
实战经验 | 1. 当出现很复杂的sql的或者jpql的时候建议用视图
        | 2. 返回结果一定要用对象接收，最好每个对象里面的字段和你返回的结果一一对应。
        | 3. 动态的query param会在后面的章节中讲到。
        | 4. 能用JPQL的就不要用sql。

